Конспект по SQL 

CREATE DATABASE sql_course; # создаст базу данных с именем sql_course

SHOW DATABASES; показать базы данных
mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sakila             |
| sql_course        |
| sys                |
| world              |
+--------------------+

DROP DATABASE sql_course; #удалит базу данных sql_course

USE sql_course; #ИСПОЛЬЗОВАТЬ базу данных sql_course

CREATE TABLE teacher(
id INT AUTO_INCREMENT PRIMARY KEY, #первая колонка
#id - название колонки INT - будет числовым значением
# AUTO_INCREMENT - автоинкрементация, будет автоматически заполнятся, 
# каждый раз повышаясяь на единицу  
# PRIMARY KEY - первычный ключ 
surname VARCHAR(255) 
# surname название колонки
# VARCHAR(255) - строковое значение
# NOT NULL - значение не может быть пустым
); # заканчиваем колонки
mysql> CREATE TABLE teacher(
    -> id INT AUTO_INCREMENT PRIMARY KEY,
    -> surname VARCHAR(255) NOT NULL
    -> );


show tables; # показать таблицы
+----------------------+
| Tables_in_sql_course |
+----------------------+
| teacher              |
+----------------------+


show columns FROM teacher; # показать колонки ИЗ teacher
mysql> show columns FROM teacher;
+---------+--------------+------+-----+---------+----------------+
| Field   | Type         | Null | Key | Default | Extra          |
+---------+--------------+------+-----+---------+----------------+
| id      | int          | NO   | PRI | NULL    | auto_increment |
| surname | varchar(255) | NO   |     | NULL    |                |
+---------+--------------+------+-----+---------+----------------+



CREATE TABLE lessons(
id INT AUTO_INCREMENT PRIMARY KEY,
name VARCHAR(255) NOT NULL,
teacher_id INT NOT NULL,
FOREIGN KEY (teacher_id) references teacher(id) #внешний ключ с ссылкой на teacher(id)
);

INSERT INTO teacher (surname) values ("Иванов"); # ВСТАВИТЬ В teacher в колонку (surname) значение ("Иванов")

SELECT * FROM teacher # SELECT запрос данных, 
# название полей (* - означает все поля) FROM - из таблицы teacher 
+----+---------+
| id | surname |
+----+---------+
|  1 | Иванов  |
|  2 | Петров  |
|  3 | Сидоров |
|  4 | Петров  |
|  5 | Чижкин  |
|  6 | Петров  |
+----+---------+

SELECT id, surname, surname from teacher; #можно показать нужные колонки через запятую (даже несколько раз)
+----+---------+---------+
| id | surname | surname |
+----+---------+---------+
|  1 | Иванов  | Иванов  |
|  2 | Петров  | Петров  |
|  3 | Сидоров | Сидоров |
|  4 | Петров  | Петров  |
|  5 | Чижкин  | Чижкин  |
|  6 | Петров  | Петров  |
+----+---------+---------+

SELECT DISTINCT surname FROM teacher; #DISTINCT - уникальные значения
+---------+
| surname |
+---------+
| Иванов  |
| Петров  | #Петров встречается в таблице несколько раз, но DISTINCT покажет одну
| Сидоров |
| Чижкин  |
+---------+

SELECT * FROM teacher WHERE id = 1; #ключевое слово WHERE, покажет данные таблицы где id = 1
+----+---------+
| id | surname |
+----+---------+
|  1 | Иванов  |
+----+---------+

#можно использовать знаки больше или меньше
SELECT * FROM teacher WHERE id > 3; # покажет значения где id больше 3
+----+---------+
| id | surname |
+----+---------+
|  4 | Петров  |
|  5 | Чижкин  |
|  6 | Петров  |
+----+---------+

SELECT * FROM teacher WHERE surname = "Петров"; #если поле строчное, то значение должно быть в ковычках
+----+---------+
| id | surname |
+----+---------+
|  2 | Петров  |
|  4 | Петров  |
|  6 | Петров  |
+----+---------+

SELECT * FROM teacher WHERE surname = "Петров" LIMIT 2; # из за LIMIT 2 будет показано только 2 значения
+----+---------+
| id | surname |
+----+---------+
|  2 | Петров  |
|  4 | Петров  |
+----+---------+

SELECT * FROM teacher LIMIT 4;
+----+---------+
| id | surname |
+----+---------+
|  1 | Иванов  |
|  2 | Петров  |
|  3 | Сидоров |
|  4 | Петров  |
+----+---------+

# Можно вызвать данные с измененными названиями колонок;
SELECT id AS 'Номер', surname AS 'Фамилия' FROM teacher;
+-------+---------+
| Номер | Фамилия |
+-------+---------+
|     1 | Иванов  |
|     2 | Петров  |
|     3 | Сидоров |
|     4 | Петров  |
|     5 | Чижкин  |
|     6 | Петров  |
+-------+---------+
# это не поменяет сами названия колонок, и если вызвать данные еще раз:
select * from teacher;
+----+---------+
| id | surname | #колонки с исходными названиями
+----+---------+
|  1 | Иванов  |
|  2 | Петров  |
|  3 | Сидоров |
|  4 | Петров  |
|  5 | Чижкин  |
|  6 | Петров  |
+----+---------+

#сортировка данных
SELECT * FROM teacher ORDER BY surname; #ORDER BY сортерует ПО, в данном случае по фамилии
+----+---------+
| id | surname |
+----+---------+
|  1 | Иванов  |
|  2 | Петров  |
|  4 | Петров  |
|  6 | Петров  |
|  3 | Сидоров |
|  5 | Чижкин  |
+----+---------+

SELECT * FROM teacher ORDER BY id;# сортерует по id
+----+---------+
| id | surname |
+----+---------+
|  1 | Иванов  |
|  2 | Петров  |
|  3 | Сидоров |
|  4 | Петров  |
|  5 | Чижкин  |
|  6 | Петров  |
+----+---------+

SELECT * FROM teacher ORDER BY id DESC; #DESC сортерует в обратном порядке
+----+---------+
| id | surname |
+----+---------+
|  6 | Петров  |
|  5 | Чижкин  |
|  4 | Петров  |
|  3 | Сидоров |
|  2 | Петров  |
|  1 | Иванов  |
+----+---------+


#ДОБАВЛЕНИЕ КОЛОНОК В ТАБЛИЦУ с помощью команды ALTER
ALTER TABLE teacher ADD age INT; # добавить в таблицу teacher колонку age с INT (цифровым значением)
show columns from teacher; #выдаст
+---------+--------------+------+-----+---------+----------------+
| Field   | Type         | Null | Key | Default | Extra          |
+---------+--------------+------+-----+---------+----------------+
| id      | int          | NO   | PRI | NULL    | auto_increment |
| surname | varchar(255) | NO   |     | NULL    |                |
| age     | int          | YES  |     | NULL    |                | # новая колонка
+---------+--------------+------+-----+---------+----------------+

mysql> select * from teacher; #покажем всю таблицу
+----+---------+------+
| id | surname | age  |
+----+---------+------+
|  1 | Иванов  | NULL |
|  2 | Петров  | NULL |
|  3 | Сидоров | NULL |
|  4 | Петров  | NULL |
|  5 | Чижкин  | NULL |
|  6 | Петров  | NULL |
+----+---------+------+
#в колонке age нет значений

#обновляем значение с помощью команды UPDATE
UPDATE teacher SET age = 20 where id=1;
#обновить таблицу teacher
#установить SET age = 20 где id = 1;
select * from teacher;
+----+---------+------+
| id | surname | age  |
+----+---------+------+
|  1 | Иванов  |   20 | #установили
|  2 | Петров  | NULL |
|  3 | Сидоров | NULL |
|  4 | Петров  | NULL |
|  5 | Чижкин  | NULL |
|  6 | Петров  | NULL |
+----+---------+------+

UPDATE teacher SET age = 25; # если не установить условие ГДЕ (WHERE), то изменится вся колонка age
select * from teacher;
+----+---------+------+
| id | surname | age  |
+----+---------+------+
|  1 | Иванов  |   25 |
|  2 | Петров  |   25 |
|  3 | Сидоров |   25 |
|  4 | Петров  |   25 |
|  5 | Чижкин  |   25 |
|  6 | Петров  |   25 |
+----+---------+------+

#...поменяли возсраст всех

select * from teacher;
+----+---------+------+
| id | surname | age  |
+----+---------+------+
|  1 | Иванов  |   25 |
|  2 | Петров  |   30 |
|  3 | Сидоров |   35 |
|  4 | Петров  |   40 |
|  5 | Чижкин  |   45 |
|  6 | Петров  |   50 |
+----+---------+------+
# ключевое слово LIKE

select * from teacher WHERE surname LIKE "%ов"; # покажет значения где есть фамилияб
# которая в окончании содержит "ов"
+----+---------+------+
| id | surname | age  |
+----+---------+------+
|  1 | Иванов  |   25 |
|  2 | Петров  |   30 |
|  3 | Сидоров |   35 |
|  4 | Петров  |   40 |
|  6 | Петров  |   50 |
+----+---------+------+

select * from teacher WHERE surname LIKE "%ин";
+----+---------+------+
| id | surname | age  |
+----+---------+------+
|  5 | Чижкин  |   45 |
+----+---------+------+

mysql> select * from teacher WHERE surname LIKE "%тр%"; 
# покажет значения в колонке с фамилиями, где в середине есть "тр"
+----+---------+------+
| id | surname | age  |
+----+---------+------+
|  2 | Петров  |   30 |
|  4 | Петров  |   40 |
|  6 | Петров  |   50 |
+----+---------+------+

# ЛОГИЧЕСКИЕ операции
select * from teacher WHERE id > 3 AND age < 46;
#покажет данные где id больше трех И (AND) age меньше 46
+----+---------+------+
| id | surname | age  |
+----+---------+------+
|  4 | Петров  |   40 |
|  5 | Чижкин  |   45 |
+----+---------+------+

select * from teacher WHERE id > 4 OR age > 31;
#покажет всех где id больше 4 или age больше 31
+----+---------+------+
| id | surname | age  |
+----+---------+------+
|  3 | Сидоров |   35 |
|  4 | Петров  |   40 |
|  5 | Чижкин  |   45 |
|  6 | Петров  |   50 |
+----+---------+------+

#можно исползовать отрицание NOT
select * from teacher WHERE NOT id > 3;
#показать где не будет id больше 3
+----+---------+------+
| id | surname | age  |
+----+---------+------+
|  1 | Иванов  |   25 |
|  2 | Петров  |   30 |
|  3 | Сидоров |   35 |
+----+---------+------+

#BETWEEN МЕЖДУ
select * from teacher WHERE age BETWEEN 35 AND 45;
# покажет таблицу где age между 35 и 45 включительно
+----+---------+------+
| id | surname | age  |
+----+---------+------+
|  3 | Сидоров |   35 |
|  4 | Петров  |   40 |
|  5 | Чижкин  |   45 |
+----+---------+------+

#удаления из таблицы
DELETE FROM teacher WHERE id = 6; #удалит строчку где id=6
#если не указать условие что удалить, удалятся все данные в таблице
mysql> select * from teacher;
+----+---------+------+
| id | surname | age  |
+----+---------+------+
|  1 | Иванов  |   25 |
|  2 | Петров  |   30 |
|  3 | Сидоров |   35 |
|  4 | Петров  |   40 |
|  5 | Чижкин  |   45 |
+----+---------+------+


# можно вставить в таблицу значения одной строчкой
INSERT INTO lesson (name, teacher_id) VALUES ("Математика", 1), ("Информатика", 1), ("Русский", 2), ("Физика", 3);
# INSERT INTO lesson - вставить в таблицу lesson
# (name, teacher_id) - я так понял это формат по которому будут введены данные
# VALUES ("Математика", 1) - значения через запятую, тут как бы все что вводишь 
# будет распределятся по колонкам в соответсвии с этим форматом (name, teacher_id)
select * from lesson;
+----+-------------+------------+
| id | name        | teacher_id |
+----+-------------+------------+
|  1 | Математика  |          1 |
|  2 | Информатика |          1 |
|  3 | Русский     |          2 |
|  4 | Физика      |          3 |
+----+-------------+------------+

# объединение таблиц
# Мы хотим объединить таблцы "уроки" и "учителя"

# при объединении JOIN или INNERJOIN 
# в этоговую таблицу войдут только учителя, у которых есть уроки
SELECT teacher.surname, lesson.name FROM teacher INNER JOIN С ON teacher.id = lesson.teacher_id;
# teacher.surname, lesson.name - то что войдет в итоговую таблицу
# FROM teacher - левая таблица
# INNER JOIN lesson - привая таблица
# ON - ключивое слово
# teacher.id = lesson.teacher_id - как будет связываться: в таблице teacher есть столбец id, а таблице lesson столбец teacher_id
+---------+-------------+
| surname | name        |
+---------+-------------+
| Иванов  | Математика  |
| Иванов  | Информатика |
| Петров  | Русский     |
| Сидоров | Физика      |
+---------+-------------+
# поскольку не все преподы имеют уроки, таблица состоит из 4х строчек


# при объединении OUTERJOIN
SELECT teacher.surname, lesson.name FROM teacher LEFT OUTER JOIN lesson ON teacher.id = lesson.teacher_id;
+---------+-------------+
| surname | name        |
+---------+-------------+
| Иванов  | Математика  |
| Иванов  | Информатика |
| Петров  | Русский     |
| Сидоров | Физика      |
| Петров  | NULL        |
| Чижкин  | NULL        |
+---------+-------------+ 
# объединение произошло по LEFT OUTER JOIN, по этому не все имеют уроки и в таблице есть null

# что будет при RIGHT OUTER JOIN
SELECT teacher.surname, lesson.name FROM teacher RIGHT OUTER JOIN lesson ON teacher.id = lesson.teacher_id;
+---------+-------------+
| surname | name        |
+---------+-------------+
| Иванов  | Математика  |
| Иванов  | Информатика |
| Петров  | Русский     |
| Сидоров | Физика      |
+---------+-------------+
# по скольку в таблице уроков нет такого урока, который бы не имел учителя, данная таблица не отличается от INNER JOIN

#вертикальное объединение с помощью UNION
SELECT * FROM teacher UNION SELECT * FROM lesson;
+----+-------------+------+
| id | surname     | age  |
+----+-------------+------+
|  1 | Иванов      |   25 |
|  2 | Петров      |   30 |
|  3 | Сидоров     |   35 |
|  4 | Петров      |   40 |
|  5 | Чижкин      |   45 |
|  1 | Математика  |    1 |
|  2 | Информатика |    1 |
|  3 | Русский     |    2 |
|  4 | Физика      |    3 |
+----+-------------+------+
# как видно, при таком объединении есть проблема с наименованием колонок

#агрегатные функции
#AVG
SELECT AVG(age) FROM teacher;
+----------+
| AVG(age) |
+----------+
|  35.0000 |
+----------+
#функция возвращает среднее значение в колонке age

#MAX MIN
SELECT MAX(age), MIN(age) FROM teacher;
+----------+----------+
| MAX(age) | MIN(age) |
+----------+----------+
|       45 |       25 |
+----------+----------+
#возвращает максимальное и минимальное значение

#SUM
SELECT SUM(age) FROM teacher;
+----------+
| SUM(age) |
+----------+
|      175 |
+----------+
# возвращает сумму всех данных в колонке age

##### добавили пару фамилий в таблицу###

#COUNT (подсчет)
select age, COUNT(age) from teacher GROUP BY age;
+------+------------+
| age  | COUNT(age) |
+------+------------+
|   25 |          2 |
|   30 |          2 |
|   35 |          1 |
|   40 |          1 |
|   45 |          1 |
+------+------------+
# т.е. эта хрень посчитала "возрасты" и сгрупировала их


#несколько задач:
# дана таблица demographics:
id
name
birthday
race
# Нужно вернуть такую же таблицу, но колонку race в нижнем регистре.
# решение:
SELECT id, name, birthday, LOWER(race) race from demographics;
# вызвал все колонки, 
# LOWER(race) race - LOWER ставит в нижний регистр колонку (race), 
# race после скобок, это как будет назваться эта колонка во время вызова

#есть таблица 'companies' нужно вернуть эту же таблицу, отсортированную по количеству employees (от большего к меньшему)
companies table schema
id
ceo
motto
employees
#решение:
SELECT * FROM companies ORDER BY employees DESC;
# вызвали всю таблицу, сортированную по employees, DESC означает от большего к меньшему